import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

import java.text.ParseException;
import java.util.Arrays;
import java.util.List;
import java.util.Map;

import com.fasterxml.jackson.core.JsonProcessingException;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@ExtendWith(MockitoExtension.class)
public class DataChangeAlertServiceTest {

    @Mock
    private DataChangeAlertRepository dataChangeAlertRepository;

    @Mock
    private Logger log;

    @InjectMocks
    private DataChangeAlertService dataChangeAlertService;

    private List<DataChangeAlertDto> mockDtoList;

    @BeforeEach
    void setUp() {
        // Create mock DataChangeAlertDto objects with various scenarios
        DataChangeAlertDto dto1 = new DataChangeAlertDto();
        dto1.setEntityName("AltCode");
        dto1.setKeys(Map.of("alt_code_type_cd", "spn"));

        DataChangeAlertDto dto2 = new DataChangeAlertDto();
        dto2.setEntityName("AltCode");
        dto2.setKeys(Map.of("alt_code_type_cd", "other"));

        DataChangeAlertDto dto3 = new DataChangeAlertDto();
        dto3.setEntityName("OtherCode");
        dto3.setKeys(Map.of("alt_code_type_cd", "other"));

        // This DTO will have null keys, simulating a potential source of NullPointerException
        DataChangeAlertDto dto4 = new DataChangeAlertDto();
        dto4.setEntityName("AltCode");
        dto4.setKeys(null);

        mockDtoList = Arrays.asList(dto1, dto2, dto3, dto4);

        // Setup logging mock to avoid null pointer
        log = LoggerFactory.getLogger(DataChangeAlertServiceTest.class);
    }

    @Test
    void testPopulateDataChangeAlerts() throws ParseException, JsonProcessingException {
        // Call the service method with the mock data
        dataChangeAlertService.populateDataChangeAlerts(mockDtoList);

//////////
public void populateDataChangeAlerts(final List<DataChangeAlertDto> dataChangeAlerts) {
    List<DataChangeAlertEntity> dataChangeAlertEntities = dataChangeAlerts.stream()
        .filter(it -> {
            if (StringUtils.isNotEmpty(it.getEntityName()) && "AltCode".equals(it.getEntityName())) {
                // Check if keys is null or the key alt_code_type_cd is missing
                Map<String, String> keys = it.getKeys();
                if (keys == null || StringUtils.isEmpty(keys.get("alt_code_type_cd"))) {
                    return true;
                }
                String altCodeTypeCd = keys.get("alt_code_type_cd");
                return "spn".equals(altCodeTypeCd);
            }
            return true;
        })
        .map(it -> {
            try {
                return DataChangeAlertEntity.build(it);
            } catch (ParseException | JsonProcessingException exception) {
                throw new RuntimeException(exception);
            }
        })
        .toList();

    log.info("'{}' records are supposed to be populated out of '{}' data change alerts.", dataChangeAlerts.size(), dataChangeAlertEntities.size());
    List<List<DataChangeAlertEntity>> transSubLists = Lists.partition(dataChangeAlertEntities, batchSize);
    transSubLists.forEach(dataChangeAlertRepository::saveAll);
}


        // Verify that saveAll was called with the correct number of elements
        verify(dataChangeAlertRepository).saveAll(any(List.class));
    }
}

@Override
public Map<String, String> getEntitiesAndFilterColumnsByQuery(Optional<PandaDataRadixConfigProperties.RadixQueryProperties> radixQueryProperties) {
    return radixQueryProperties
             .map(radixQueryProps -> 
                  radixQueryProps.getEntities().stream()
                                 .flatMap(entity -> entity.getName().stream()
                                     .map(name -> new AbstractMap.SimpleEntry<>(name, entity.getFilterColumns().get(0)))) // Create a new entry
                                 .collect(Collectors.toMap(
                                     entry -> entry.getKey(),  // Use lambda instead of method reference
                                     entry -> entry.getValue() // Use lambda instead of method reference
                                 )))
             .orElse(new LinkedHashMap<>());
}
/////////////////- 2:49
public Map<String, Object> getFilters(Map<String, String> entityAndFilterColumn) {
    Map<String, Object> result = new LinkedHashMap<>();
    
    entityAndFilterColumn.forEach((entityName, filterColumn) -> {
        log.info("Processing entity: " + entityName + " with filter column: " + filterColumn);

        List<NotificationDetails> notificationDetailsList = notificationRepository.findAllByIsProcessedAndSourceSystemAndEntityName(
            "N", "panda", entityName);
        
        // Initialize or retrieve the existing list from the result map
        List<String> filters = (List<String>) result.computeIfAbsent(filterColumn, k -> new ArrayList<>());
        
        // Process notification details and add to the filters list
        for (NotificationDetails notificationDetails : notificationDetailsList) {
            try {
                if ("N".equals(notificationDetails.getIsProcessed())) {
                    processNotificationDetails(notificationDetails, filterColumn, filters);
                } else if ("Y".equals(notificationDetails.getIsProcessed())) {
                    log.info("Skipping processing for NotificationDetails with isProcessed = Y");
                }
            } catch (JsonProcessingException e) {
                log.error("Error processing NotificationDetails", e);
            }
        }
    });

    return result;
}

//////// 3:20

public String toCamelCase(String filter) {
    return filter.replaceAll("_(.)", m -> m.group(1).toUpperCase());
}

